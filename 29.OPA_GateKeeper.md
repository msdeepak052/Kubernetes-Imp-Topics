# Open Policy Agent (OPA) Webhook Authorization

## What is OPA Webhook Authorization?

**OPA** (Open Policy Agent) is an **open-source, general-purpose policy engine** that decouples policy decision-making from policy enforcement. It uses a high-level, declarative language called **Rego** for writing policies.

In the context of Kubernetes, **OPA Webhook Authorization** refers to using OPA as an external policy decision point (PDP) for the Kubernetes API Server's **Authorization Webhook**.

1.  **Request Flow:** When a user or service account makes an API request (e.g., `kubectl apply -f pod.yaml`), the Kubernetes API server first authenticates the user, then checks the built-in authorizers (like RBAC), and finally calls any configured external Webhook Authorizers.
2.  **Webhook Call:** The API server sends a JSON payload called a **`SubjectAccessReview`** to the OPA service (the webhook server). This payload contains all the context: the user, groups, resource type, API verb (get, create, delete, etc.), and other details.
3.  **Policy Decision:** The OPA service evaluates this `SubjectAccessReview` input against its loaded Rego policies.
4.  **Response:** OPA returns a simple JSON response indicating whether the request is **allowed** or **denied**, along with an optional reason.

This mechanism allows you to inject custom, complex, and data-aware authorization logic into the core Kubernetes control plane.

-----

## Why is it Needed if RBAC is Present?

Kubernetes' built-in **Role-Based Access Control (RBAC)** is a fundamental and excellent authorization system, but it has inherent limitations that OPA Webhook Authorization is designed to overcome:

| Feature | Kubernetes RBAC | OPA Webhook Authorization |
| :--- | :--- | :--- |
| **Model** | **Role-Based:** Defines permissions based on roles (who has which role). | **Attribute/Policy-Based (ABAC/PBAC):** Defines permissions based on attributes of the user, the resource, and the context. |
| **Granularity** | Coarse-grained. Decides based on **Who** (user/group/service account), **What** (resource), and **Action** (verb). | Fine-grained. Can decide based on **any attribute** inside the request or external data (e.g., time of day, department, specific resource labels, or even external database lookups). |
| **Logic** | Primarily **Whitelisting** (What is explicitly allowed). Explicit **Deny** is not directly supported within RBAC policies. | Supports both **Whitelisting** and powerful **Blacklisting/Denial** logic (What is explicitly forbidden), which is crucial for security. |
| **Policy Language** | YAML/JSON structures (`Role`, `RoleBinding`). | **Rego**: A dedicated, declarative policy language that supports complex logic (e.g., loops, joins, calculations). |
| **Contextual Data**| Limited to the data in the K8s API objects (`User`, `Group`, `Resource`). | Can integrate **external data** (e.g., a list of on-call users, a user's geographical location from an HR system) into the authorization decision. |

In short, **RBAC handles the "what-can-this-user-do-on-this-resource" well, but OPA handles the "under-what-conditions-can-this-user-do-this-action" far better.**

-----

## What OPA Webhook Authorization Gives Out of the Box

By using OPA as your authorization webhook, you immediately gain the following powerful capabilities, often referred to as "Policy-as-Code" features:

1.  **Centralized, Unified Policy Enforcement:** OPA isn't just for Kubernetes; it can be used for API Gateways, Service Meshes (Istio/Envoy), application authorization, SSH, and CI/CD pipelines. It provides a **single, consistent policy language (Rego)** across your entire technology stack.
2.  **Complex Policy Logic:** The Rego language allows for logic that is impossible or impractical with native RBAC, such as:
      * **Time-based access:** *Allow "admin" access only during business hours.*
      * **Blacklisting/Prohibition:** *Explicitly deny all requests to the 'kube-system' namespace for all non-admin users.*
      * **Relationship-based access:** *Allow users to view resources that have a label matching their department.*
3.  **Data-Driven Decisions:** Policies can utilize external data (fetched or pushed to OPA) to inform decisions. For example, checking if a user is in the current "On-Call" rotation list stored in an external database.
4.  **Policy Testing and Validation:** Rego supports **unit testing** for policies, treating authorization logic like any other code. This is a massive improvement over traditional configuration-based authorization systems.
5.  **Auditability and Visibility:** OPA can log every policy query and decision, providing a clear, centralized audit trail of all authorization decisions made across your system.

-----

## Demo: Explicitly Deny Access to `kube-system` Namespace

This is a classic example of an **explicit denial** that is simple to achieve with OPA but difficult with pure RBAC. We'll set up a minimal Kubernetes cluster, deploy OPA, and configure the Authorization Webhook.

### Prerequisites

  * A running Kubernetes cluster (e.g., Minikube).
  * `kubectl` installed and configured.
  * `openssl` for generating TLS certificates (required for the webhook).

### 1\. Setup Namespace and TLS Certificates

The communication between the Kubernetes API server and your OPA webhook must be secured with TLS.

#### File: `setup_tls.sh`

```bash
#!/bin/bash
# 1. Create a namespace for OPA
kubectl create namespace opa

# 2. Generate CA Certificate and Key
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -sha256 -key ca.key -days 100000 -out ca.crt -subj "/CN=opa-webhook-ca"

# 3. Create a config file for the OPA server certificate
cat > server.conf <<EOF
[ req ]
prompt = no
req_extensions = v3_ext
distinguished_name = dn

[ dn ]
# This CN MUST match the OPA Service name: opa.opa.svc
CN = opa.opa.svc

[ v3_ext ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, serverAuth
# This SAN MUST match the OPA Service name and its full internal K8s DNS
subjectAltName = DNS:opa.opa.svc,DNS:opa.opa.svc.cluster.local
EOF

# 4. Generate the OPA server certificate and key
openssl genrsa -out server.key 2048
openssl req -new -key server.key -sha256 -out server.csr -extensions v3_ext -config server.conf
openssl x509 -req -in server.csr -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 100000 -extensions v3_ext -extfile server.conf

# 5. Create a Kubernetes Secret for the TLS files
kubectl create secret tls opa-server-tls --cert=server.crt --key=server.key -n opa
```

**Run the script:**

```bash
bash setup_tls.sh
```

### 2\. Define the OPA Authorization Policy (Rego)

This policy explicitly denies any request to **delete** or **create** resources in the `kube-system` namespace, unless the user is named `admin`.

#### File: `policy.rego`

```rego
package kubernetes.authz

# By default, all requests are allowed.
default allow = true

# Rule to explicitly deny access to the kube-system namespace
# This policy is evaluated first because of the 'deny' keyword.
deny[msg] {
    # Check if the requested namespace is 'kube-system'
    input.resourceAttributes.namespace == "kube-system"
    
    # Check if the operation is 'delete' or 'create'
    input.resourceAttributes.verb == "delete"
    
    # Check if the user is NOT the 'admin' user
    input.user.username != "admin"
    
    # Set the denial message
    msg := "DENIED: Only 'admin' user can delete resources in the 'kube-system' namespace."
}

deny[msg] {
    # Check if the requested namespace is 'kube-system'
    input.resourceAttributes.namespace == "kube-system"
    
    # Check if the operation is 'delete' or 'create'
    input.resourceAttributes.verb == "create"
    
    # Check if the user is NOT the 'admin' user
    input.user.username != "admin"
    
    # Set the denial message
    msg := "DENIED: Only 'admin' user can create resources in the 'kube-system' namespace."
}
```

**Note:** In OPA's implementation as an authorization webhook, if the policy returns a `deny` result, the request is forbidden. If it returns `allow: true` or has no opinion (no `deny` rule matches), the request continues to the next authorizer (usually RBAC).

### 3\. Deploy OPA as a Kubernetes Deployment

This deployment runs the OPA container, loads the policy, and exposes its webhook endpoint.

#### File: `opa-deployment.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: opa
data:
  policy.rego: |
    package kubernetes.authz

    # By default, allow all requests if no 'deny' rule is met.
    default allow = true

    # Rule 1: Deny DELETE access to the kube-system namespace for non-admins
    deny[msg] {
        input.resourceAttributes.namespace == "kube-system"
        input.resourceAttributes.verb == "delete"
        input.user.username != "admin"
        msg := "DENIED by OPA: Only 'admin' user can delete resources in the 'kube-system' namespace."
    }

    # Rule 2: Deny CREATE access to the kube-system namespace for non-admins
    deny[msg] {
        input.resourceAttributes.namespace == "kube-system"
        input.resourceAttributes.verb == "create"
        input.user.username != "admin"
        msg := "DENIED by OPA: Only 'admin' user can create resources in the 'kube-system' namespace."
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: opa
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest
        args:
          - "run"
          - "--server"
          - "--tls-cert-file=/certs/server.crt"
          - "--tls-private-key-file=/certs/server.key"
          - "--addr=:8443"
          - "--set=decision_logs.enabled=true" # Enable decision logging
          - "/policy/policy.rego"
        volumeMounts:
          - name: opa-tls
            mountPath: /certs
            readOnly: true
          - name: opa-policy-volume
            mountPath: /policy
      volumes:
        - name: opa-tls
          secret:
            secretName: opa-server-tls
        - name: opa-policy-volume
          configMap:
            name: opa-policy
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: opa
spec:
  selector:
    app: opa
  ports:
  - port: 443
    targetPort: 8443
```

**Apply the deployment:**

```bash
kubectl apply -f opa-deployment.yaml
```

### 4\. Configure Kubernetes Authorization Webhook

This tells the Kubernetes API server to send authorization requests to the OPA service.

#### File: `authz-webhook-config.yaml`

```yaml
# Note: You MUST replace the <CA_BUNDLE> placeholder with the base64 encoded content of ca.crt
apiVersion: v1
kind: Config
clusters:
  - name: opa
    cluster:
      # OPA Service DNS name in K8s: https://opa.opa.svc:443
      server: https://opa.opa.svc:443/v1/data/kubernetes/authz
      # The CA bundle to validate OPA's server certificate
      certificate-authority-data: <CA_BUNDLE>
users:
  - name: apiserver
contexts:
  - name: opa-context
    context:
      cluster: opa
      user: apiserver
current-context: opa-context
```

**Get the CA Bundle and create the final config file:**

1.  **Get the base64 CA bundle:**
    ```bash
    export CA_BUNDLE=$(cat ca.crt | base64 | tr -d '\n')
    ```
2.  **Create a temporary file for the final config:**
    ```bash
    cat <<EOF > authz-webhook.conf
    apiVersion: v1
    kind: Config
    clusters:
      - name: opa
        cluster:
          server: https://opa.opa.svc:443/v1/data/kubernetes/authz
          certificate-authority-data: ${CA_BUNDLE}
    users:
      - name: apiserver
    contexts:
      - name: opa-context
        context:
          cluster: opa
          user: apiserver
    current-context: opa-context
    EOF
    ```

### 5\. Configure API Server to Use the Webhook

This is the only step that requires restarting the Kubernetes API server, as webhook authorizer configuration is static. For a local setup like Minikube, you can often modify the startup flags.

**Minikube/Kubeadm (Illustrative Step - exact flags depend on your setup):**

You need to add a flag to the `kube-apiserver` process telling it about the webhook configuration file:

```bash
# This is an illustrative command for a typical setup. 
# On Minikube, you might have to SSH in or use 'minikube start --extra-config'
# The goal is to start the kube-apiserver with this flag:
# --authorization-webhook-config-file=/path/to/authz-webhook.conf 
# and ensure 'Webhook' is in the --authorization-mode.

# Example if running as a static pod (find the manifest and edit it)
# --authorization-mode=Node,RBAC,Webhook
# --authorization-webhook-config-file=/etc/kubernetes/authz-webhook.conf
```

For a simple local test environment, the easiest way to demonstrate is often by setting up a proxy or using a dedicated testing environment that supports dynamic configuration. Since editing the API server flags is complex and environment-dependent, we'll assume this step is complete for the purpose of the policy test.

### 6\. Test the Policy

Assuming the API server is now configured to use the webhook:

1.  **Create a test user (non-admin):** We'll create a new Service Account and get its token to simulate a non-admin user.

    ```bash
    kubectl create serviceaccount test-user -n default
    # Grant basic RBAC access so the request reaches the OPA webhook
    kubectl create role pod-reader --verb=get,list,watch,create,delete --resource=pods -n kube-system
    kubectl create rolebinding test-user-role-binding --role=pod-reader --serviceaccount=default:test-user -n kube-system

    # Get the token (methods vary by K8s version, here is a modern way)
    export TEST_TOKEN=$(kubectl create token test-user -n default --duration 24h)

    # Define an alias to use the test user
    alias testuser_kubectl="kubectl --token=$TEST_TOKEN"
    ```

2.  **Attempt a denied action (Delete a Pod in `kube-system`):**

    ```bash
    # Try to delete a pod in the kube-system namespace as 'test-user'
    # This should be DENIED by OPA
    testuser_kubectl delete pod/some-pod-name -n kube-system
    ```

    **Expected Result:** An error message from the Kubernetes API server, saying the request is **forbidden** because of the authorization policy, echoing the message set in the Rego:

    ```
    Error from server (Forbidden): DENIED: Only 'admin' user can delete resources in the 'kube-system' namespace.
    ```

3.  **Attempt an allowed action (Delete a Pod in another namespace):**

    ```bash
    # Try to delete a pod in the 'default' namespace as 'test-user'
    # This should be allowed (or denied by RBAC if no role is present, 
    # but OPA should not deny it)
    testuser_kubectl delete pod/another-pod-name -n default
    ```

    **Expected Result:** The request should pass the OPA webhook (since no `deny` rule matched) and likely be denied by the subsequent RBAC authorizer if the `test-user` has no permissions in the `default` namespace, or be successful if they do. The key is that **OPA didn't explicitly deny it**.

    That's a great request\! A well-organized file structure makes any policy-as-code demo much easier to follow and manage.

Here is the recommended folder and file structure for the OPA Webhook Authorization demo I outlined, including a brief description of each file.

## Demo File Structure

The entire demo can reside in a single directory, which we'll call `opa-authz-demo`.

```
opa-authz-demo/
├── policy.rego              # The Rego policy that denies access to 'kube-system'.
├── setup_tls.sh            # Script to generate TLS certs (ca.crt, server.crt, server.key).
├── authz-webhook-config.yaml # Template for the Kubeconfig file required by the API server.
├── opa-deployment.yaml     # Kubernetes Deployment and Service for OPA, and the ConfigMap for policy.rego.
└── TESTING.md              # Instructions and commands to test the policy.
```

-----

## Detailed File Contents

### 1\. `policy.rego`

This file contains the core authorization logic in Rego.

```rego
package kubernetes.authz

# By default, allow all requests if no 'deny' rule is met.
default allow = true

# Rule to explicitly deny the deletion of resources in the 'kube-system' namespace.
deny[msg] {
    # Check for the target namespace
    input.resourceAttributes.namespace == "kube-system"
    
    # Check for the action (verb)
    input.resourceAttributes.verb == "delete"
    
    # Check for the user (The username 'admin' is explicitly excluded from denial)
    input.user.username != "admin"
    
    # Message returned to the user
    msg := "DENIED by OPA: Only 'admin' user can delete resources in the 'kube-system' namespace."
}

# Rule to explicitly deny the creation of resources in the 'kube-system' namespace.
deny[msg] {
    input.resourceAttributes.namespace == "kube-system"
    input.resourceAttributes.verb == "create"
    input.user.username != "admin"
    msg := "DENIED by OPA: Only 'admin' user can create resources in the 'kube-system' namespace."
}
```

### 2\. `setup_tls.sh`

This script handles the TLS certificate generation, which is a required step for any Kubernetes webhook.

```bash
#!/bin/bash
# 1. Create a namespace for OPA
kubectl create namespace opa

# 2. Generate CA Certificate and Key
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -sha256 -key ca.key -days 100000 -out ca.crt -subj "/CN=opa-webhook-ca"

# 3. Create a config file for the OPA server certificate
cat > server.conf <<EOF
[ req ]
prompt = no
req_extensions = v3_ext
distinguished_name = dn

[ dn ]
# This CN MUST match the OPA Service name: opa.opa.svc
CN = opa.opa.svc

[ v3_ext ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, serverAuth
# This SAN MUST match the OPA Service name and its full internal K8s DNS
subjectAltName = DNS:opa.opa.svc,DNS:opa.opa.svc.cluster.local
EOF

# 4. Generate the OPA server certificate and key
openssl genrsa -out server.key 2048
openssl req -new -key server.key -sha256 -out server.csr -extensions v3_ext -config server.conf
openssl x509 -req -in server.csr -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 100000 -extensions v3_ext -extfile server.conf

# 5. Create a Kubernetes Secret for the TLS files
kubectl create secret tls opa-server-tls --cert=server.crt --key=server.key -n opa

# 6. Generate the final webhook config file (authz-webhook.conf)
echo "Generating final authz-webhook.conf..."
export CA_BUNDLE=$(cat ca.crt | base64 | tr -d '\n')
cat > authz-webhook.conf <<EOF
apiVersion: v1
kind: Config
clusters:
  - name: opa
    cluster:
      # OPA Service DNS name in K8s: https://opa.opa.svc:443
      server: https://opa.opa.svc:443/v1/data/kubernetes/authz
      # The CA bundle to validate OPA's server certificate
      certificate-authority-data: ${CA_BUNDLE}
users:
  - name: apiserver
contexts:
  - name: opa-context
    context:
      cluster: opa
      user: apiserver
current-context: opa-context
EOF

echo "TLS setup complete. authz-webhook.conf is ready for API server configuration."
```

### 3\. `opa-deployment.yaml`

This manifest deploys the OPA engine, its Service, and the ConfigMap containing the Rego policy.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: opa
data:
  # The content of policy.rego is loaded here
  policy.rego: |
    package kubernetes.authz
    
    default allow = true
    
    deny[msg] {
        input.resourceAttributes.namespace == "kube-system"
        input.resourceAttributes.verb == "delete"
        input.user.username != "admin"
        msg := "DENIED by OPA: Only 'admin' user can delete resources in the 'kube-system' namespace."
    }
    
    deny[msg] {
        input.resourceAttributes.namespace == "kube-system"
        input.resourceAttributes.verb == "create"
        input.user.username != "admin"
        msg := "DENIED by OPA: Only 'admin' user can create resources in the 'kube-system' namespace."
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: opa
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest-gatekeeper
        args:
          - "run"
          - "--server"
          # Use TLS files from the secret volume
          - "--tls-cert-file=/certs/server.crt"
          - "--tls-key-file=/certs/server.key"
          - "--addr=:8443"
          - "--set=decision_logs.enabled=true"
          - "/policy/policy.rego"
        volumeMounts:
          - name: opa-tls
            mountPath: /certs
            readOnly: true
          - name: opa-policy-volume
            mountPath: /policy
      volumes:
        - name: opa-tls
          secret:
            secretName: opa-server-tls
        - name: opa-policy-volume
          configMap:
            name: opa-policy
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: opa
spec:
  selector:
    app: opa
  ports:
  - port: 443 # The port the API server calls
    targetPort: 8443 # The port OPA listens on
```

### 4\. `TESTING.md`

This file contains the commands needed for testing the policy once the API server is configured.

```markdown
# OPA Authorization Webhook Demo Testing Steps

## 1. Apply OPA Deployment
kubectl apply -f opa-deployment.yaml

## 2. Wait for OPA Pod to be ready
kubectl rollout status deployment/opa -n opa

## 3. Create a test non-admin user (Service Account)

### A. Create a minimal resource (needed for testing a DELETE)
kubectl create deployment test-deployment --image=nginx -n kube-system

### B. Create the non-admin user (Service Account)
kubectl create serviceaccount non-admin-user -n default

### C. Grant the non-admin-user RBAC access to DELETE Pods in kube-system
# This shows OPA's explicit DENY logic overrides RBAC's ALLOW logic.
kubectl create rolebinding non-admin-deleter --role=system:kube-scheduler --serviceaccount=default:non-admin-user -n kube-system

### D. Get the Service Account Token
export TEST_TOKEN=$(kubectl create token non-admin-user -n default --duration 24h)

### E. Define a convenient alias
alias testuser_kubectl="kubectl --token=$TEST_TOKEN"


## 4. Test the DENY Policy (Expected: Forbidden)

# Attempt to delete a resource in the 'kube-system' namespace as the non-admin user
echo "--- Testing DENY (delete in kube-system) ---"
testuser_kubectl delete deployment/test-deployment -n kube-system

# Expected Output:
# Error from server (Forbidden): DENIED by OPA: Only 'admin' user can delete resources in the 'kube-system' namespace.


## 5. Test the ALLOW Path (Expected: Allowed/Handled by RBAC)

# Attempt to delete a resource in a NON-SYSTEM namespace (e.g., 'default')
echo "--- Testing ALLOW (delete in default) ---"
testuser_kubectl delete deployment/some-other-deployment -n default

# Expected Output:
# Error from server (Forbidden): deployments.apps "some-other-deployment" is forbidden: User "system:serviceaccount:default:non-admin-user" cannot delete resource "deployments" in API group "apps" in the namespace "default"
# 
# NOTE: OPA allowed the request to pass (no DENY rule matched), but it was then denied by RBAC because the user has no permissions in the 'default' namespace. This proves OPA is active and not denying the default namespace!
```
