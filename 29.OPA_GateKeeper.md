# Open Policy Agent (OPA) Webhook Authorizatio

## What is OPA Webhook Authorization?

**OPA** (Open Policy Agent) is an **open-source, general-purpose policy engine** that decouples policy decision-making from policy enforcement. It uses a high-level, declarative language called **Rego** for writing policies.

In the context of Kubernetes, **OPA Webhook Authorization** refers to using OPA as an external policy decision point (PDP) for the Kubernetes API Server's **Authorization Webhook**.

1.  **Request Flow:** When a user or service account makes an API request (e.g., `kubectl apply -f pod.yaml`), the Kubernetes API server first authenticates the user, then checks the built-in authorizers (like RBAC), and finally calls any configured external Webhook Authorizers.
2.  **Webhook Call:** The API server sends a JSON payload called a **`SubjectAccessReview`** to the OPA service (the webhook server). This payload contains all the context: the user, groups, resource type, API verb (get, create, delete, etc.), and other details.
3.  **Policy Decision:** The OPA service evaluates this `SubjectAccessReview` input against its loaded Rego policies.
4.  **Response:** OPA returns a simple JSON response indicating whether the request is **allowed** or **denied**, along with an optional reason.

This mechanism allows you to inject custom, complex, and data-aware authorization logic into the core Kubernetes control plane.

-----

## Why is it Needed if RBAC is Present?

Kubernetes' built-in **Role-Based Access Control (RBAC)** is a fundamental and excellent authorization system, but it has inherent limitations that OPA Webhook Authorization is designed to overcome:

| Feature | Kubernetes RBAC | OPA Webhook Authorization |
| :--- | :--- | :--- |
| **Model** | **Role-Based:** Defines permissions based on roles (who has which role). | **Attribute/Policy-Based (ABAC/PBAC):** Defines permissions based on attributes of the user, the resource, and the context. |
| **Granularity** | Coarse-grained. Decides based on **Who** (user/group/service account), **What** (resource), and **Action** (verb). | Fine-grained. Can decide based on **any attribute** inside the request or external data (e.g., time of day, department, specific resource labels, or even external database lookups). |
| **Logic** | Primarily **Whitelisting** (What is explicitly allowed). Explicit **Deny** is not directly supported within RBAC policies. | Supports both **Whitelisting** and powerful **Blacklisting/Denial** logic (What is explicitly forbidden), which is crucial for security. |
| **Policy Language** | YAML/JSON structures (`Role`, `RoleBinding`). | **Rego**: A dedicated, declarative policy language that supports complex logic (e.g., loops, joins, calculations). |
| **Contextual Data**| Limited to the data in the K8s API objects (`User`, `Group`, `Resource`). | Can integrate **external data** (e.g., a list of on-call users, a user's geographical location from an HR system) into the authorization decision. |

In short, **RBAC handles the "what-can-this-user-do-on-this-resource" well, but OPA handles the "under-what-conditions-can-this-user-do-this-action" far better.**

-----

## What OPA Webhook Authorization Gives Out of the Box

By using OPA as your authorization webhook, you immediately gain the following powerful capabilities, often referred to as "Policy-as-Code" features:

1.  **Centralized, Unified Policy Enforcement:** OPA isn't just for Kubernetes; it can be used for API Gateways, Service Meshes (Istio/Envoy), application authorization, SSH, and CI/CD pipelines. It provides a **single, consistent policy language (Rego)** across your entire technology stack.
2.  **Complex Policy Logic:** The Rego language allows for logic that is impossible or impractical with native RBAC, such as:
      * **Time-based access:** *Allow "admin" access only during business hours.*
      * **Blacklisting/Prohibition:** *Explicitly deny all requests to the 'kube-system' namespace for all non-admin users.*
      * **Relationship-based access:** *Allow users to view resources that have a label matching their department.*
3.  **Data-Driven Decisions:** Policies can utilize external data (fetched or pushed to OPA) to inform decisions. For example, checking if a user is in the current "On-Call" rotation list stored in an external database.
4.  **Policy Testing and Validation:** Rego supports **unit testing** for policies, treating authorization logic like any other code. This is a massive improvement over traditional configuration-based authorization systems.
5.  **Auditability and Visibility:** OPA can log every policy query and decision, providing a clear, centralized audit trail of all authorization decisions made across your system.

-----

## Demo: Explicitly Deny Access to `kube-system` Namespace

This is a classic example of an **explicit denial** that is simple to achieve with OPA but difficult with pure RBAC. We'll set up a minimal Kubernetes cluster, deploy OPA, and configure the Authorization Webhook.

### Prerequisites

  * A running Kubernetes cluster (e.g., Minikube).
  * `kubectl` installed and configured.
  * `openssl` for generating TLS certificates (required for the webhook).

### 1\. Setup Namespace and TLS Certificates

The communication between the Kubernetes API server and your OPA webhook must be secured with TLS.

#### File: `setup_tls.sh`

```bash
#!/bin/bash
# 1. Create a namespace for OPA
kubectl create namespace opa

# 2. Generate CA Certificate and Key
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -sha256 -key ca.key -days 100000 -out ca.crt -subj "/CN=opa-webhook-ca"

# 3. Create a config file for the OPA server certificate
cat > server.conf <<EOF
[ req ]
prompt = no
req_extensions = v3_ext
distinguished_name = dn

[ dn ]
# This CN MUST match the OPA Service name: opa.opa.svc
CN = opa.opa.svc

[ v3_ext ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, serverAuth
# This SAN MUST match the OPA Service name and its full internal K8s DNS
subjectAltName = DNS:opa.opa.svc,DNS:opa.opa.svc.cluster.local
EOF

# 4. Generate the OPA server certificate and key
openssl genrsa -out server.key 2048
openssl req -new -key server.key -sha256 -out server.csr -extensions v3_ext -config server.conf
openssl x509 -req -in server.csr -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 100000 -extensions v3_ext -extfile server.conf

# 5. Create a Kubernetes Secret for the TLS files
kubectl create secret tls opa-server-tls --cert=server.crt --key=server.key -n opa
```

**Run the script:**

```bash
bash setup_tls.sh
```

### 2\. Define the OPA Authorization Policy (Rego)

This policy explicitly denies any request to **delete** or **create** resources in the `kube-system` namespace, unless the user is named `admin`.

#### File: `policy.rego`

```rego
package kubernetes.authz

# By default, all requests are allowed.
default allow = true

# Rule to explicitly deny access to the kube-system namespace
# This policy is evaluated first because of the 'deny' keyword.
deny[msg] {
    # Check if the requested namespace is 'kube-system'
    input.resourceAttributes.namespace == "kube-system"
    
    # Check if the operation is 'delete' or 'create'
    input.resourceAttributes.verb == "delete"
    
    # Check if the user is NOT the 'admin' user
    input.user.username != "admin"
    
    # Set the denial message
    msg := "DENIED: Only 'admin' user can delete resources in the 'kube-system' namespace."
}

deny[msg] {
    # Check if the requested namespace is 'kube-system'
    input.resourceAttributes.namespace == "kube-system"
    
    # Check if the operation is 'delete' or 'create'
    input.resourceAttributes.verb == "create"
    
    # Check if the user is NOT the 'admin' user
    input.user.username != "admin"
    
    # Set the denial message
    msg := "DENIED: Only 'admin' user can create resources in the 'kube-system' namespace."
}
```

**Note:** In OPA's implementation as an authorization webhook, if the policy returns a `deny` result, the request is forbidden. If it returns `allow: true` or has no opinion (no `deny` rule matches), the request continues to the next authorizer (usually RBAC).

### 3\. Deploy OPA as a Kubernetes Deployment

This deployment runs the OPA container, loads the policy, and exposes its webhook endpoint.

#### File: `opa-deployment.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: opa
data:
  policy.rego: |
    # (Copy the content of policy.rego file here)
    package kubernetes.authz
    
    default allow = true
    
    deny[msg] {
        input.resourceAttributes.namespace == "kube-system"
        input.resourceAttributes.verb == "delete"
        input.user.username != "admin"
        msg := "DENIED: Only 'admin' user can delete resources in the 'kube-system' namespace."
    }
    
    deny[msg] {
        input.resourceAttributes.namespace == "kube-system"
        input.resourceAttributes.verb == "create"
        input.user.username != "admin"
        msg := "DENIED: Only 'admin' user can create resources in the 'kube-system' namespace."
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: opa
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest-gatekeeper
        args:
          - "run"
          - "--server"
          - "--tls-cert-file=/certs/server.crt"
          - "--tls-key-file=/certs/server.key"
          - "--addr=:8443"
          - "--set=decision_logs.enabled=true" # Enable decision logging
          - "/policy/policy.rego"
        volumeMounts:
          - name: opa-tls
            mountPath: /certs
            readOnly: true
          - name: opa-policy-volume
            mountPath: /policy
      volumes:
        - name: opa-tls
          secret:
            secretName: opa-server-tls
        - name: opa-policy-volume
          configMap:
            name: opa-policy
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: opa
spec:
  selector:
    app: opa
  ports:
  - port: 443
    targetPort: 8443
```

**Apply the deployment:**

```bash
kubectl apply -f opa-deployment.yaml
```

### 4\. Configure Kubernetes Authorization Webhook

This tells the Kubernetes API server to send authorization requests to the OPA service.

#### File: `authz-webhook-config.yaml`

```yaml
# Note: You MUST replace the <CA_BUNDLE> placeholder with the base64 encoded content of ca.crt
apiVersion: v1
kind: Config
clusters:
  - name: opa
    cluster:
      # OPA Service DNS name in K8s: https://opa.opa.svc:443
      server: https://opa.opa.svc:443/v1/data/kubernetes/authz
      # The CA bundle to validate OPA's server certificate
      certificate-authority-data: <CA_BUNDLE>
users:
  - name: apiserver
contexts:
  - name: opa-context
    context:
      cluster: opa
      user: apiserver
current-context: opa-context
```

**Get the CA Bundle and create the final config file:**

1.  **Get the base64 CA bundle:**
    ```bash
    export CA_BUNDLE=$(cat ca.crt | base64 | tr -d '\n')
    ```
2.  **Create a temporary file for the final config:**
    ```bash
    cat <<EOF > authz-webhook.conf
    apiVersion: v1
    kind: Config
    clusters:
      - name: opa
        cluster:
          server: https://opa.opa.svc:443/v1/data/kubernetes/authz
          certificate-authority-data: ${CA_BUNDLE}
    users:
      - name: apiserver
    contexts:
      - name: opa-context
        context:
          cluster: opa
          user: apiserver
    current-context: opa-context
    EOF
    ```

### 5\. Configure API Server to Use the Webhook

This is the only step that requires restarting the Kubernetes API server, as webhook authorizer configuration is static. For a local setup like Minikube, you can often modify the startup flags.

**Minikube/Kubeadm (Illustrative Step - exact flags depend on your setup):**

You need to add a flag to the `kube-apiserver` process telling it about the webhook configuration file:

```bash
# This is an illustrative command for a typical setup. 
# On Minikube, you might have to SSH in or use 'minikube start --extra-config'
# The goal is to start the kube-apiserver with this flag:
# --authorization-webhook-config-file=/path/to/authz-webhook.conf 
# and ensure 'Webhook' is in the --authorization-mode.

# Example if running as a static pod (find the manifest and edit it)
# --authorization-mode=Node,RBAC,Webhook
# --authorization-webhook-config-file=/etc/kubernetes/authz-webhook.conf
```

For a simple local test environment, the easiest way to demonstrate is often by setting up a proxy or using a dedicated testing environment that supports dynamic configuration. Since editing the API server flags is complex and environment-dependent, we'll assume this step is complete for the purpose of the policy test.

### 6\. Test the Policy

Assuming the API server is now configured to use the webhook:

1.  **Create a test user (non-admin):** We'll create a new Service Account and get its token to simulate a non-admin user.

    ```bash
    kubectl create serviceaccount test-user -n default
    # Grant basic RBAC access so the request reaches the OPA webhook
    kubectl create role pod-reader --verb=get,list,watch,create,delete --resource=pods -n kube-system
    kubectl create rolebinding test-user-role-binding --role=pod-reader --serviceaccount=default:test-user -n kube-system

    # Get the token (methods vary by K8s version, here is a modern way)
    export TEST_TOKEN=$(kubectl create token test-user -n default --duration 24h)

    # Define an alias to use the test user
    alias testuser_kubectl="kubectl --token=$TEST_TOKEN"
    ```

2.  **Attempt a denied action (Delete a Pod in `kube-system`):**

    ```bash
    # Try to delete a pod in the kube-system namespace as 'test-user'
    # This should be DENIED by OPA
    testuser_kubectl delete pod/some-pod-name -n kube-system
    ```

    **Expected Result:** An error message from the Kubernetes API server, saying the request is **forbidden** because of the authorization policy, echoing the message set in the Rego:

    ```
    Error from server (Forbidden): DENIED: Only 'admin' user can delete resources in the 'kube-system' namespace.
    ```

3.  **Attempt an allowed action (Delete a Pod in another namespace):**

    ```bash
    # Try to delete a pod in the 'default' namespace as 'test-user'
    # This should be allowed (or denied by RBAC if no role is present, 
    # but OPA should not deny it)
    testuser_kubectl delete pod/another-pod-name -n default
    ```

    **Expected Result:** The request should pass the OPA webhook (since no `deny` rule matched) and likely be denied by the subsequent RBAC authorizer if the `test-user` has no permissions in the `default` namespace, or be successful if they do. The key is that **OPA didn't explicitly deny it**.
