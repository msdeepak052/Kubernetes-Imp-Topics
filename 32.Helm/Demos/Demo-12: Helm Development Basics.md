# **Demo-12: Helm Development Basics** 

Iâ€™ll present:

1. Goal and prerequisites
2. Step-by-step tasks you run (commands)
3. Every file (exact contents) for a sample chart called `devchart`
4. Explanations and rationale for each file/step
5. Testing, validation, packaging, and best practices

---

# ðŸŽ¯ Demo-12 â€” Helm Development Basics (Overview)

**Objective:**
Create a small, well-structured Helm chart from scratch (`devchart`) that demonstrates templating, values, helpers, conditional resources, hooks, CRD handling, dependency declaration, linting, rendering, installing, packaging, and basic tests.

**Final artifacts youâ€™ll have:**

```
demo-12-helm-dev/
â””â”€â”€ devchart/
    â”œâ”€â”€ Chart.yaml
    â”œâ”€â”€ values.yaml
    â”œâ”€â”€ charts/                 # dependencies (optional)
    â”œâ”€â”€ crds/
    â”‚   â””â”€â”€ example-crd.yaml    # optional CRD example
    â”œâ”€â”€ templates/
    â”‚   â”œâ”€â”€ _helpers.tpl
    â”‚   â”œâ”€â”€ deployment.yaml
    â”‚   â”œâ”€â”€ service.yaml
    â”‚   â”œâ”€â”€ configmap.yaml
    â”‚   â”œâ”€â”€ hpa.yaml            # optional autoscaling
    â”‚   â”œâ”€â”€ NOTES.txt
    â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â””â”€â”€ preinstall-job.yaml
    â”‚   â””â”€â”€ ingress.yaml        # optional
    â”œâ”€â”€ .helmignore
    â”œâ”€â”€ README.md
    â””â”€â”€ commands.sh
```

---

# ðŸ›  Prerequisites

Make sure you have:

* Helm 3.x installed (`helm version`)
* A Kubernetes cluster (minikube, kind, or real cluster) and `kubectl` configured
* Optional: `yq` (for editing YAML), `helm-unittest` plugin if you want unit tests

---

# 1 â€” Create the chart skeleton

Commands:

```bash
mkdir demo-12-helm-dev
cd demo-12-helm-dev
helm create devchart
# optionally remove autogenerated extras or adapt them; we'll replace files below
```

The `helm create` command sets up a working skeleton. Weâ€™ll replace files with curated content below.

---

# 2 â€” Files (copy these exact contents)

Create files under `demo-12-helm-dev/devchart/` as shown.

### `Chart.yaml`

```yaml
apiVersion: v2
name: devchart
description: A demo chart to teach Helm development basics
type: application
version: 0.1.0
appVersion: "1.0.0"
keywords:
  - demo
  - helm
  - dev
maintainers:
  - name: Deepak Yadav
    email: deepak@example.com
dependencies: [] # add dependencies here or in Chart.lock after "helm dependency update"
```

**Why:** chart metadata. `apiVersion: v2` for Helm 3 charts.

---

### `values.yaml`

```yaml
replicaCount: 1

image:
  repository: nginx
  tag: "1.25.3"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  hosts: []
  annotations: {}

resources: {}
nodeSelector: {}
tolerations: []
affinity: {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 80

# Example of a value containing a template string; shows tpl() usage later
welcomeMessage: "Welcome to {{ .Release.Name }} deployed in {{ .Release.Namespace }}"

hooks:
  enablePreInstallJob: true
```

**Why:** clear, documented defaults; features toggled by boolean flags.

---

### `crds/example-crd.yaml` (optional)

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: examples.myorg.io
spec:
  group: myorg.io
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
  scope: Namespaced
  names:
    plural: examples
    singular: example
    kind: Example
```

**Why:** CRDs must live under `crds/` and are installed before templates. Use if your chart defines CRs.

---

### `templates/_helpers.tpl`

```gotemplate
{{- /*
Common helper templates for name, labels and truncation.
*/ -}}

{{- define "devchart.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{- define "devchart.fullname" -}}
{{- $name := default .Chart.Name .Values.nameOverride -}}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{- define "devchart.labels" -}}
app.kubernetes.io/name: {{ include "devchart.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
app.kubernetes.io/version: {{ .Chart.AppVersion }}
app.kubernetes.io/managed-by: Helm
{{- end -}}
```

**Why:** helpers keep templates DRY and manage length-safe names.

---

### `templates/deployment.yaml`

```gotemplate
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "devchart.fullname" . }}
  labels:
{{ include "devchart.labels" . | indent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app.kubernetes.io/instance: {{ .Release.Name }}
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      containers:
        - name: {{ include "devchart.name" . }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: 80
          env:
            - name: WELCOME
              value: {{ tpl .Values.welcomeMessage . | quote }}
          resources:
{{ toYaml .Values.resources | indent 10 }}
      nodeSelector: {{ toYaml .Values.nodeSelector | indent 6 }}
      tolerations: {{ toYaml .Values.tolerations | indent 6 }}
      affinity: {{ toYaml .Values.affinity | indent 6 }}
```

**Why:** shows `.Values`, `tpl()` usage for templated values, `toYaml` + `indent` for nested maps.

---

### `templates/service.yaml`

```gotemplate
apiVersion: v1
kind: Service
metadata:
  name: {{ include "devchart.fullname" . }}-svc
  labels:
{{ include "devchart.labels" . | indent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: 80
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/instance: {{ .Release.Name }}
```

**Why:** simple service, uses selectors tied to release instance.

---

### `templates/configmap.yaml`

```gotemplate
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "devchart.fullname" . }}-cfg
  labels:
{{ include "devchart.labels" . | indent 4 }}
data:
  welcome: {{ tpl .Values.welcomeMessage . | quote }}
```

**Why:** demonstrates how to template ConfigMap values and reuse helpers.

---

### `templates/hpa.yaml` (conditional)

```gotemplate
{{- if .Values.autoscaling.enabled }}
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {{ include "devchart.fullname" . }}-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {{ include "devchart.fullname" . }}
  minReplicas: {{ .Values.autoscaling.minReplicas }}
  maxReplicas: {{ .Values.autoscaling.maxReplicas }}
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}
{{- end }}
```

**Why:** conditional rendering with `if`, demonstrates multi-version API choice (v2 used; check `.Capabilities` in advanced charts).

---

### `templates/hooks/preinstall-job.yaml`

```gotemplate
{{- if .Values.hooks.enablePreInstallJob }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "devchart.fullname" . }}-preinstall
  annotations:
    "helm.sh/hook": pre-install
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
spec:
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: preinstall
          image: busybox
          command: ["sh","-c","echo Pre-install hook for {{ .Release.Name }}; sleep 1"]
{{- end }}
```

**Why:** shows hooks, hook annotations, and cleanup policy. Hooks are powerful, but use them sparingly.

---

### `templates/NOTES.txt`

```
Thank you for installing {{ .Chart.Name }}!

Release: {{ .Release.Name }}
Namespace: {{ .Release.Namespace }}

To check the app:
  kubectl get pods -l app.kubernetes.io/instance={{ .Release.Name }} -n {{ .Release.Namespace }}

To get the welcome message:
  kubectl get cm {{ include "devchart.fullname" . }}-cfg -o jsonpath="{.data.welcome}" -n {{ .Release.Namespace }}
```

**Why:** user-visible tips after `helm install`.

---

### `templates/ingress.yaml` (optional)

```gotemplate
{{- if .Values.ingress.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "devchart.fullname" . }}-ing
  annotations:
{{ toYaml .Values.ingress.annotations | indent 4 }}
spec:
  rules:
{{- range .Values.ingress.hosts }}
    - host: {{ .host }}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: {{ include "devchart.fullname" $ }}
                port:
                  number: {{ $.Values.service.port }}
{{- end }}
{{- end }}
```

**Why:** conditional ingress; demonstrates `range` with context.

---

### `.helmignore`

```
*.tgz
.DS_Store
.git/
README.md
```

**Why:** reduces package size.

---

### `README.md` (chart-level)

```markdown
# devchart - Helm Development Basics Demo

This chart demonstrates Helm development basics:
- Templating with helpers (`_helpers.tpl`)
- Use of `.Values`, `.Release`, `.Chart`, and `tpl()`
- Conditional resources (HPA, Ingress)
- Hooks (pre-install Job)
- CRDs in `crds/` (if present)

Files:
- Chart.yaml: metadata
- values.yaml: default values
- templates/*: kubernetes manifests

Commands:
- Lint: `helm lint .`
- Render: `helm template myrel ./devchart -n demo`
- Install: `helm install myrel ./devchart -n demo --create-namespace`
- Uninstall: `helm uninstall myrel -n demo`
- Package: `helm package ./devchart`
```

---

### `commands.sh` (executable)

```bash
#!/usr/bin/env bash
set -euo pipefail

CHART="./devchart"
RELEASE="devchart-demo"
NAMESPACE="demo12-ns"

echo "Linting chart..."
helm lint "${CHART}"

echo "Rendering templates (dry-run)..."
helm template "${RELEASE}" "${CHART}" --namespace "${NAMESPACE}" --debug > rendered.yaml
echo "Rendered manifests saved to rendered.yaml"

echo "Create namespace..."
kubectl create namespace "${NAMESPACE}" || true

echo "Installing chart (wait for hooks and resources)..."
helm install "${RELEASE}" "${CHART}" --namespace "${NAMESPACE}" --wait

echo "Show release values..."
helm get values "${RELEASE}" -n "${NAMESPACE}" --all

echo "Show manifest applied..."
helm get manifest "${RELEASE}" -n "${NAMESPACE}"

echo "List Kubernetes resources..."
kubectl get all -n "${NAMESPACE}"

echo "To cleanup: helm uninstall ${RELEASE} -n ${NAMESPACE} && kubectl delete namespace ${NAMESPACE}"
```

Make it executable:

```bash
chmod +x commands.sh
```

---

# 3 â€” Development workflow & commands explained

### a) Lint the chart

```bash
helm lint devchart
```

**What it does:** checks best practices and template correctness. Fix lint warnings and errors before installing.

### b) Render templates locally (dry-run)

```bash
helm template myrel ./devchart -n demo12-ns --debug > out.yaml
```

**Why:** see final YAML Helm would send to Kubernetes; great to debug templating and indentation issues.

### c) Install and wait (including hooks)

```bash
helm install myrel ./devchart -n demo12-ns --create-namespace --wait
```

**Why `--wait`:** waits for resources to become ready. Hooks run according to their annotations.

### d) Inspect release

```bash
helm get all myrel -n demo12-ns
helm get values myrel -n demo12-ns
helm get manifest myrel -n demo12-ns
helm status myrel -n demo12-ns
```

### e) Upgrade

```bash
helm upgrade myrel ./devchart -n demo12-ns --set replicaCount=2 --wait
```

**Use `--atomic`** in production to rollback on failure.

### f) Uninstall & cleanup

```bash
helm uninstall myrel -n demo12-ns
kubectl delete namespace demo12-ns
```

### g) Package

```bash
helm package ./devchart
# result: devchart-0.1.0.tgz
```

**Upload the tgz** to your chart repo (ChartMuseum, OCI registry, etc).

---

# 4 â€” Testing & validation (practical tips)

* Always `helm lint` and `helm template` before `helm install`.
* Use `--dry-run --debug` on install to see potential errors:

  ```bash
  helm install myrel ./devchart -n ns --dry-run --debug
  ```
* Test variable overrides:

  * Inline: `--set image.tag=1.25.4`
  * File: `-f ci-values.yaml` for CI/test environments
* Unit testing: thereâ€™s a `helm-unittest` plugin that allows YAML-based unit tests for templates. Install and run if you want tests:

  ```bash
  helm plugin install https://github.com/quintush/helm-unittest
  helm unittest ./devchart
  ```
* Integration testing: use `kind` or `minikube` in CI to run `helm install` and assertions (pod readiness, service endpoints).

---

# 5 â€” Best practices & tips

* Keep templates simple; prefer values over complex logic.
* Use `_helpers.tpl` for names and labels to avoid duplication.
* Avoid hardcoding namespaces in templates â€” manage via `--namespace`.
* Keep CRDs in `crds/` and note CRD lifecycle; CRDs are installed before templates and not removed on uninstall.
* Use `hook-delete-policy` for ephemeral hook jobs.
* Validate Kubernetes API compatibility with `.Capabilities.APIVersions.Has` for charts targeting multiple K8s versions.
* Keep secrets out of `values.yaml`. Use external secret managers (SealedSecrets, ExternalSecrets) or `helm secrets` plugin.
* Respect 63-character resource name limits â€” use `trunc` helpers if necessary.

---

# 6 â€” Example troubleshooting checklist

If `helm lint` fails:

* Check template indentation (main cause).
* Ensure `include` functions return properly indented YAML (use `| indent N`).
* Use `helm template` to inspect the rendered YAML and find where the parser fails.

If `helm install` hangs at hooks:

* Check hook job logs: `kubectl logs job/<job-name> -n ns`
* Describe the job for events: `kubectl describe job/<job-name> -n ns`
* Use `--wait` carefully; hooks that never finish block installs.

---

# 7 â€” Next steps you can follow (optional extensions)

* Add a dependency (e.g., a Redis chart) via `Chart.yaml` and run `helm dependency update`.
* Add automated tests with `helm-unittest`.
* Publish to OCI registry: `helm push devchart-0.1.0.tgz oci://registry.example.com/helm`
* Add CI: GitHub Actions workflow for lint â†’ template â†’ install (kind) â†’ tests â†’ package.

---

# Quick run checklist (copy-paste)

```bash
cd demo-12-helm-dev
chmod +x devchart/commands.sh
# Lint
helm lint devchart
# Dry-run render
helm template demo ./devchart -n demo12-ns --debug > out.yaml
# Install
kubectl create namespace demo12-ns || true
helm install demo ./devchart -n demo12-ns --wait
# Inspect
helm get all demo -n demo12-ns
kubectl get all -n demo12-ns
# Upgrade example
helm upgrade demo ./devchart -n demo12-ns --set replicaCount=2 --wait
# Cleanup
helm uninstall demo -n demo12-ns
kubectl delete namespace demo12-ns
```

---
