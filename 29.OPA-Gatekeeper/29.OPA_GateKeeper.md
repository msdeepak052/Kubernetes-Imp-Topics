# Open Policy Agent (OPA) Webhook Authorization

## What is OPA Webhook Authorization?

**OPA** (Open Policy Agent) is an **open-source, general-purpose policy engine** that decouples policy decision-making from policy enforcement. It uses a high-level, declarative language called **Rego** for writing policies.

In the context of Kubernetes, **OPA Webhook Authorization** refers to using OPA as an external policy decision point (PDP) for the Kubernetes API Server's **Authorization Webhook**.

1.  **Request Flow:** When a user or service account makes an API request (e.g., `kubectl apply -f pod.yaml`), the Kubernetes API server first authenticates the user, then checks the built-in authorizers (like RBAC), and finally calls any configured external Webhook Authorizers.
2.  **Webhook Call:** The API server sends a JSON payload called a **`SubjectAccessReview`** to the OPA service (the webhook server). This payload contains all the context: the user, groups, resource type, API verb (get, create, delete, etc.), and other details.
3.  **Policy Decision:** The OPA service evaluates this `SubjectAccessReview` input against its loaded Rego policies.
4.  **Response:** OPA returns a simple JSON response indicating whether the request is **allowed** or **denied**, along with an optional reason.

This mechanism allows you to inject custom, complex, and data-aware authorization logic into the core Kubernetes control plane.

-----

## Why is it Needed if RBAC is Present?

Kubernetes' built-in **Role-Based Access Control (RBAC)** is a fundamental and excellent authorization system, but it has inherent limitations that OPA Webhook Authorization is designed to overcome:

| Feature | Kubernetes RBAC | OPA Webhook Authorization |
| :--- | :--- | :--- |
| **Model** | **Role-Based:** Defines permissions based on roles (who has which role). | **Attribute/Policy-Based (ABAC/PBAC):** Defines permissions based on attributes of the user, the resource, and the context. |
| **Granularity** | Coarse-grained. Decides based on **Who** (user/group/service account), **What** (resource), and **Action** (verb). | Fine-grained. Can decide based on **any attribute** inside the request or external data (e.g., time of day, department, specific resource labels, or even external database lookups). |
| **Logic** | Primarily **Whitelisting** (What is explicitly allowed). Explicit **Deny** is not directly supported within RBAC policies. | Supports both **Whitelisting** and powerful **Blacklisting/Denial** logic (What is explicitly forbidden), which is crucial for security. |
| **Policy Language** | YAML/JSON structures (`Role`, `RoleBinding`). | **Rego**: A dedicated, declarative policy language that supports complex logic (e.g., loops, joins, calculations). |
| **Contextual Data**| Limited to the data in the K8s API objects (`User`, `Group`, `Resource`). | Can integrate **external data** (e.g., a list of on-call users, a user's geographical location from an HR system) into the authorization decision. |

In short, **RBAC handles the "what-can-this-user-do-on-this-resource" well, but OPA handles the "under-what-conditions-can-this-user-do-this-action" far better.**

-----

## What OPA Webhook Authorization Gives Out of the Box

By using OPA as your authorization webhook, you immediately gain the following powerful capabilities, often referred to as "Policy-as-Code" features:

1.  **Centralized, Unified Policy Enforcement:** OPA isn't just for Kubernetes; it can be used for API Gateways, Service Meshes (Istio/Envoy), application authorization, SSH, and CI/CD pipelines. It provides a **single, consistent policy language (Rego)** across your entire technology stack.
2.  **Complex Policy Logic:** The Rego language allows for logic that is impossible or impractical with native RBAC, such as:
      * **Time-based access:** *Allow "admin" access only during business hours.*
      * **Blacklisting/Prohibition:** *Explicitly deny all requests to the 'kube-system' namespace for all non-admin users.*
      * **Relationship-based access:** *Allow users to view resources that have a label matching their department.*
3.  **Data-Driven Decisions:** Policies can utilize external data (fetched or pushed to OPA) to inform decisions. For example, checking if a user is in the current "On-Call" rotation list stored in an external database.
4.  **Policy Testing and Validation:** Rego supports **unit testing** for policies, treating authorization logic like any other code. This is a massive improvement over traditional configuration-based authorization systems.
5.  **Auditability and Visibility:** OPA can log every policy query and decision, providing a clear, centralized audit trail of all authorization decisions made across your system.

-----

## OPA Webhook Authorization: Detailed Explanation

### Why OPA Webhook Authorization when RBAC exists?

**RBAC Limitations:**
- **Static permissions**: RBAC works with predefined roles and permissions
- **Limited context**: Cannot make decisions based on resource attributes, user context, or external data
- **No custom logic**: Cannot implement complex business rules
- **Kubernetes-specific**: Tied to Kubernetes ecosystem

**OPA Advantages:**
- **Dynamic authorization**: Make decisions based on any attribute (time, resource content, user location, etc.)
- **Fine-grained control**: Implement complex policies beyond simple allow/deny
- **Policy-as-code**: Write policies in Rego language, version control them
- **Cross-platform**: Same policy engine can be used across different systems
- **External data integration**: Make decisions based on external data sources

### What OPA Webhook Authorization Provides

1. **External Authorization Webhook**: Kubernetes calls OPA for authorization decisions
2. **Custom Policy Logic**: Implement complex business rules
3. **Attribute-Based Access Control (ABAC)**: Decisions based on multiple attributes
4. **Audit Trail**: Detailed logging of authorization decisions
5. **Centralized Policy Management**: Manage policies across multiple clusters

## Complete Demo Setup

### Architecture
```
Kubernetes API Server → OPA Webhook → Rego Policies → Decision (Allow/Deny)
```

### Step 1: Setup OPA as Kubernetes Admission Controller

#### 1.1 Create Namespace
```yaml
# opa-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: opa
  labels:
    name: opa
```

#### 1.2 Create OPA ConfigMap with Policies
```yaml
# opa-policies.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: opa
  name: opa-policies
data:
  main.rego: |
    package system

    import data.kubernetes.admission

    main = {
      "apiVersion": "admission.k8s.io/v1",
      "kind": "AdmissionReview",
      "response": response,
    }

    default response = {"allowed": true}

    response = {
      "allowed": false,
      "status": {
        "reason": reason,
      },
    } {
      reason = concat(", ", admission.deny)
      reason != ""
    }
    
  kubernetes.rego: |
    package kubernetes.admission

    import future.keywords.in

    # Deny if any violations exist
    deny contains reason {
      some violation in data.policies.deny
      reason := violation.reason
    }

    # Check namespace policies
    deny contains reason {
      not input_check_namespace_quota
      reason := "Namespace quota exceeded"
    }

    # Check pod security policies
    deny contains reason {
      not input_check_pod_security
      reason := "Pod security policy violation"
    }

    # Check resource limits
    deny contains reason {
      not input_check_resource_limits
      reason := "Resource limits violation"
    }

    input_check_namespace_quota {
      # Get the namespace of the resource
      namespace := input.request.namespace
        
      # Count existing pods in the namespace
      pods := [p | p := data.kubernetes.pods[namespace][_]]
      count(pods) < 10  # Allow maximum 10 pods per namespace
    }

    input_check_pod_security {
      input.request.kind.kind == "Pod"
      
      # Check if pod has security context
      spec := input.request.object.spec
      spec.securityContext.runAsNonRoot == true
      spec.securityContext.runAsUser > 10000
    }

    input_check_resource_limits {
      input.request.kind.kind == "Pod"
      
      # Check all containers have resource limits
      spec := input.request.object.spec
      container := spec.containers[_]
      container.resources.limits.cpu
      container.resources.limits.memory
    }
    
  business-policies.rego: |
    package policies.deny

    import future.keywords.in

    # Deny deployments during maintenance window
    deny[{"reason": reason}] {
      time.now_ns() >= maintenance_window_start
      time.now_ns() <= maintenance_window_end
      input.request.kind.kind == "Deployment"
      reason := "Deployments not allowed during maintenance window (2 AM - 4 AM UTC)"
    }

    # Deny privileged containers
    deny[{"reason": reason}] {
      input.request.kind.kind == "Pod"
      container := input.request.object.spec.containers[_]
      container.securityContext.privileged == true
      reason := sprintf("Privileged containers are not allowed: %v", [container.name])
    }

    # Deny latest image tags
    deny[{"reason": reason}] {
      input.request.kind.kind in {"Pod", "Deployment"}
      container := input.request.object.spec.containers[_]
      endswith(container.image, ":latest")
      reason := sprintf("Latest image tags are not allowed: %v", [container.image])
    }

    # Deny root user
    deny[{"reason": reason}] {
      input.request.kind.kind == "Pod"
      input.request.object.spec.securityContext.runAsUser == 0
      reason := "Running as root user is not allowed"
    }

    # Maintenance window: 2 AM to 4 AM UTC
    maintenance_window_start = time.parse_rfc3339_ns("2024-01-01T02:00:00Z")
    maintenance_window_end = time.parse_rfc3339_ns("2024-01-01T04:00:00Z")

    # Allow specific service accounts to bypass policies
    bypass_policies {
      input.request.userInfo.groups[_] == "system:masters"
    }

    bypass_policies {
      input.request.userInfo.username == "system:serviceaccount:kube-system:cluster-admin"
    }
```

#### 1.3 Create OPA Deployment
```yaml
# opa-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: opa
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
        - name: opa
          image: openpolicyagent/opa:0.58.0
          args:
            - "run"
            - "--server"
            - "--addr=0.0.0.0:8181"
            - "--set=decision_logs.console=true"
            - "--set=services.kubernetes.local.url=http://localhost:8001"
            - "--ignore=.*"
            - "/policies"
          volumeMounts:
            - name: opa-policies
              mountPath: /policies
          ports:
            - containerPort: 8181
          livenessProbe:
            httpGet:
              path: /health
              port: 8181
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /health
              port: 8181
            initialDelaySeconds: 5
            periodSeconds: 5
      volumes:
        - name: opa-policies
          configMap:
            name: opa-policies
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: opa
spec:
  selector:
    app: opa
  ports:
    - port: 8181
      targetPort: 8181
```

#### 1.4 Create Validating Webhook Configuration
```yaml
# webhook-configuration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: opa-validating-webhook
webhooks:
  - name: validating-webhook.opa.example.com
    clientConfig:
      service:
        namespace: opa
        name: opa
        path: /v1/data/kubernetes/admission
        port: 8181
      caBundle: ""  # This will be filled by the setup script
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["*"]
        apiVersions: ["*"]
        resources: ["*"]
    admissionReviewVersions: ["v1"]
    sideEffects: None
    timeoutSeconds: 5
    failurePolicy: Fail
```

### Step 2: Setup Script

#### setup-opa.sh
```bash
#!/bin/bash

set -e

echo "Setting up OPA Webhook Authorization..."

# Create namespace
kubectl apply -f opa-namespace.yaml

# Create OPA policies
kubectl apply -f opa-policies.yaml

# Create OPA deployment
kubectl apply -f opa-deployment.yaml

# Wait for OPA to be ready
echo "Waiting for OPA to be ready..."
kubectl wait --for=condition=ready pod -l app=opa -n opa --timeout=60s

# Get the CA bundle from the service account
CA_BUNDLE=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}')

if [ -z "$CA_BUNDLE" ]; then
    # For environments without CA bundle (like Docker Desktop)
    CA_BUNDLE=$(kubectl get secret -n opa $(kubectl get secret -n opa | grep opa-token | awk '{print $1}') -o jsonpath='{.data.ca\.crt}')
fi

# Create webhook configuration with CA bundle
cat > webhook-configuration-with-ca.yaml <<EOF
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: opa-validating-webhook
webhooks:
  - name: validating-webhook.opa.example.com
    clientConfig:
      service:
        namespace: opa
        name: opa
        path: /v1/data/kubernetes/admission
        port: 8181
      caBundle: $CA_BUNDLE
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["*"]
        apiVersions: ["*"]
        resources: ["*"]
    admissionReviewVersions: ["v1"]
    sideEffects: None
    timeoutSeconds: 5
    failurePolicy: Fail
EOF

# Apply webhook configuration
kubectl apply -f webhook-configuration-with-ca.yaml

echo "OPA webhook setup completed!"
echo ""
echo "Test the setup with:"
echo "kubectl apply -f test-pod.yaml"
```

### Step 3: Test Resources

#### 3.1 Test Pod that should be DENIED
```yaml
# test-pod-denied.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-denied
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:latest  # Violation: latest tag
    securityContext:
      privileged: true  # Violation: privileged container
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      # Missing limits - violation
  securityContext:
    runAsUser: 0  # Violation: root user
```

#### 3.2 Test Pod that should be ALLOWED
```yaml
# test-pod-allowed.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-allowed
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:1.21  # Specific version
    securityContext:
      privileged: false
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
  securityContext:
    runAsUser: 10001  # Non-root user
    runAsNonRoot: true
```

#### 3.3 Test Deployment
```yaml
# test-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        securityContext:
          privileged: false
      securityContext:
        runAsUser: 10001
        runAsNonRoot: true
```

### Step 4: Verification and Testing Script

#### test-opa.sh
```bash
#!/bin/bash

echo "Testing OPA Webhook Policies..."

echo ""
echo "1. Testing DENIED pod (should fail):"
kubectl apply -f test-pod-denied.yaml || echo "Expected failure - Policy violations detected"

echo ""
echo "2. Testing ALLOWED pod (should succeed):"
kubectl apply -f test-pod-allowed.yaml

echo ""
echo "3. Testing ALLOWED deployment (should succeed):"
kubectl apply -f test-deployment.yaml

echo ""
echo "4. Checking OPA logs:"
kubectl logs -l app=opa -n opa --tail=20

echo ""
echo "5. Checking pod status:"
kubectl get pods

echo ""
echo "Test completed!"
```

### Step 5: Advanced Policy Examples

#### advanced-policies.yaml
```yaml
# advanced-policies.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: opa
  name: advanced-policies
data:
  advanced.rego: |
    package policies.advanced

    import future.keywords.in

    # Organization-specific policies
    deny[{"reason": reason}] {
      # Deny resources in production namespace without proper labels
      input.request.namespace == "production"
      not valid_production_labels
      reason := "Production resources require app and environment labels"
    }

    deny[{"reason": reason}] {
      # Deny large resource requests in dev namespaces
      input.request.namespace == "development"
      input.request.kind.kind == "Pod"
      container := input.request.object.spec.containers[_]
      container.resources.requests.cpu > cores("1")
      reason := "Development namespace limited to 1 CPU per container"
    }

    deny[{"reason": reason}] {
      # Require specific annotations for ingress resources
      input.request.kind.kind == "Ingress"
      not input.request.object.metadata.annotations["kubernetes.io/ingress.class"]
      reason := "Ingress resources require kubernetes.io/ingress.class annotation"
    }

    deny[{"reason": reason}] {
      # Time-based restrictions for production deployments
      input.request.namespace == "production"
      input.request.kind.kind == "Deployment"
      not deployment_time_allowed
      reason := "Production deployments only allowed during business hours (9 AM - 5 PM UTC)"
    }

    # Helper functions
    valid_production_labels {
      input.request.object.metadata.labels.app
      input.request.object.metadata.labels.environment == "production"
    }

    deployment_time_allowed {
      hour := time.clock(time.now_ns())[0]
      hour >= 9
      hour <= 17
    }

    cores(str) = num {
      # Convert CPU string to cores
      endswith(str, "m")
      num = to_number(trim(str, "m")) / 1000
    }

    cores(str) = num {
      not endswith(str, "m")
      num = to_number(str)
    }
```

### Step 6: Complete Deployment

#### 6.1 Update the setup to include advanced policies
```bash
#!/bin/bash
# deploy-complete.sh

echo "Deploying complete OPA setup..."

# Apply all resources
kubectl apply -f opa-namespace.yaml
kubectl apply -f opa-policies.yaml
kubectl apply -f advanced-policies.yaml
kubectl apply -f opa-deployment.yaml

# Wait for OPA
kubectl wait --for=condition=ready pod -l app=opa -n opa --timeout=60s

# Setup webhook (use the same CA bundle logic from setup-opa.sh)
./setup-opa.sh

echo "Deployment complete!"
```

### Step 7: Monitoring and Debugging

#### 7.1 Check OPA decisions
```bash
# View OPA logs
kubectl logs -l app=opa -n opa -f

# Check webhook configuration
kubectl get validatingwebhookconfiguration

# Test policy evaluation
kubectl port-forward -n opa svc/opa 8181:8181 &
curl -X POST http://localhost:8181/v1/data/kubernetes/admission -d @test-request.json
```

#### 7.2 Sample test request
```json
{
  "apiVersion": "admission.k8s.io/v1",
  "kind": "AdmissionReview",
  "request": {
    "uid": "test-uid",
    "kind": {"kind": "Pod", "version": "v1"},
    "resource": {"group": "", "version": "v1", "resource": "pods"},
    "namespace": "default",
    "operation": "CREATE",
    "userInfo": {
      "username": "test-user",
      "groups": ["system:authenticated"]
    },
    "object": {
      "metadata": {"name": "test-pod"},
      "spec": {
        "containers": [{
          "name": "test",
          "image": "nginx:latest",
          "securityContext": {"privileged": true}
        }],
        "securityContext": {"runAsUser": 0}
      }
    }
  }
}
```

## Summary

This complete demo provides:

1. **OPA Webhook Setup**: Full configuration for OPA as admission controller
2. **Comprehensive Policies**: Multiple policy examples covering security, resources, and business rules
3. **Testing Framework**: Resources to test both allowed and denied scenarios
4. **Advanced Features**: Time-based restrictions, organizational policies
5. **Operational Tools**: Scripts for setup, testing, and monitoring

The key advantage is that OPA allows you to implement complex authorization logic that would be impossible with standard RBAC, such as:
- Time-based deployment restrictions
- Resource quota enforcement across namespaces
- Complex security policies
- Business rule validation
- External data integration

This provides much finer-grained control over your Kubernetes cluster security and compliance.

---

# Complete OPA Webhook Authorization Demo - Manual Step-by-Step Guide

## Overview
This demo shows how OPA extends Kubernetes RBAC with fine-grained, policy-based authorization using Validating Webhooks.

## Why OPA when RBAC exists?
- **RBAC**: Role-based, static permissions
- **OPA**: Attribute-based, dynamic policies with custom logic
- **Use Cases**: Security policies, cost control, compliance, business rules

## Architecture
```
Kubernetes API Server → OPA Webhook (HTTPS) → Rego Policies → Allow/Deny Decision
```

---

## Step 1: Create TLS Certificates

### Why TLS?
Kubernetes requires HTTPS for webhook communication to ensure secure API server-to-webhook communication.

#### 1.1 Create Certificate Authority (CA)
```bash
# Create CA private key
openssl genrsa -out ca.key 2048

# Create CA certificate
openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt -subj "/CN=opa-ca"
```

#### 1.2 Create OPA Server Certificate
```bash
# Create config file for certificate
cat > opa.cnf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = opa.opa.svc
DNS.2 = opa.opa.svc.cluster.local
EOF

# Create OPA private key
openssl genrsa -out opa.key 2048

# Create certificate signing request
openssl req -new -key opa.key -out opa.csr -subj "/CN=opa.opa.svc" -config opa.cnf

# Sign the certificate with CA
openssl x509 -req -in opa.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out opa.crt -days 3650 -extensions v3_req -extfile opa.cnf
```

**Files created:**
- `ca.key`, `ca.crt` - Certificate Authority
- `opa.key`, `opa.crt` - OPA server certificate
- `opa.csr` - Certificate signing request

---

## Step 2: Create Kubernetes Namespace

### Why separate namespace?
Isolates OPA resources and provides clean separation from other workloads.

```bash
kubectl create namespace opa
```

**File: `01-namespace.yaml`**
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: opa
  labels:
    name: opa
    admission: enabled
```

Apply:
```bash
kubectl apply -f 01-namespace.yaml
```

---

## Step 3: Create TLS Secret

### Why Secret?
Securely stores TLS certificates in Kubernetes so OPA pod can access them.


Apply (replace placeholders):
```bash

# Create TLS secret with proper type
kubectl create secret tls opa-server-tls \
  --namespace=opa \
  --cert=opa.crt \
  --key=opa.key \
  --dry-run=client -o yaml > 02-tls-secret.yaml


 # Then add ca.crt separately since 'tls' secret type doesn't include CA
echo "  ca.crt: $(base64 -w 0 ca.crt)" >> 02-tls-secret.yaml

# Apply the secret
kubectl apply -f 02-tls-secret.yaml
 
```

---

## Step 4: Create OPA Policies ConfigMap

### Why ConfigMap?
Stores Rego policies as configuration that can be mounted into OPA container.

**File: `03-policies-configmap.yaml`**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: opa
  name: opa-policies
  labels:
    app: opa
data:
  main.rego: |
    package system

    import data.kubernetes.admission

    main = {
      "apiVersion": "admission.k8s.io/v1",
      "kind": "AdmissionReview",
      "response": response,
    }

    default response = {"allowed": true}

    response = {
      "uid": input.request.uid,
      "allowed": false,
      "status": {
        "reason": reason,
      },
    } {
      reason = concat(", ", admission.deny)
      reason != ""
    }
    
  kubernetes.rego: |
    package kubernetes.admission

    import future.keywords.in

    # Deny if any violations exist
    deny contains reason {
      some violation in data.policies.deny
      reason := violation.reason
    }

    # Check pod security policies
    deny contains reason {
      input.request.kind.kind == "Pod"
      not input_check_pod_security
      reason := "Pod security policy violation"
    }

    # Check resource limits
    deny contains reason {
      input.request.kind.kind == "Pod"
      not input_check_resource_limits
      reason := "Resource limits violation: CPU and memory limits are required"
    }

    input_check_pod_security {
      spec := input.request.object.spec
      spec.securityContext.runAsNonRoot == true
      spec.securityContext.runAsUser > 10000
    }

    input_check_resource_limits {
      spec := input.request.object.spec
      container := spec.containers[_]
      container.resources.limits
      container.resources.limits.cpu
      container.resources.limits.memory
    }
    
  policies.rego: |
    package policies.deny

    import future.keywords.in

    # Policy 1: Deny privileged containers
    deny[{"reason": reason}] {
      input.request.kind.kind == "Pod"
      container := input.request.object.spec.containers[_]
      container.securityContext.privileged == true
      reason := sprintf("Privileged containers are not allowed: %v", [container.name])
    }

    # Policy 2: Deny latest image tags
    deny[{"reason": reason}] {
      input.request.kind.kind in {"Pod", "Deployment"}
      container := input.request.object.spec.containers[_]
      endswith(container.image, ":latest")
      reason := sprintf("Latest image tags are not allowed: %v", [container.image])
    }

    # Policy 3: Deny root user
    deny[{"reason": reason}] {
      input.request.kind.kind == "Pod"
      input.request.object.spec.securityContext.runAsUser == 0
      reason := "Running as root user is not allowed"
    }

    # Policy 4: Deny host namespace sharing
    deny[{"reason": reason}] {
      input.request.kind.kind == "Pod"
      input.request.object.spec.hostNetwork == true
      reason := "Host network sharing is not allowed"
    }

    # Policy 5: Deny host PID sharing
    deny[{"reason": reason}] {
      input.request.kind.kind == "Pod"
      input.request.object.spec.hostPID == true
      reason := "Host PID sharing is not allowed"
    }

    # Allow cluster admins to bypass policies
    bypass_policies {
      input.request.userInfo.groups[_] == "system:masters"
    }
```

Apply:
```bash
kubectl apply -f 03-policies-configmap.yaml
```

---

## Step 5: Create OPA Deployment

### Why Deployment?
Runs OPA as a long-running service with proper health checks and TLS configuration.

**File: `04-opa-deployment.yaml`**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: opa
  labels:
    app: opa
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
        - name: opa
          image: openpolicyagent/opa:0.61.0
          args:
            - "run"
            - "--server"
            - "--addr=0.0.0.0:8181"
            - "--tls-cert-file=/certs/tls.crt"
            - "--tls-private-key-file=/certs/tls.key"
            - "--set=decision_logs.console=true"
            - "--ignore=.*"
            - "/policies"
          volumeMounts:
            - name: opa-policies
              mountPath: /policies
            - name: opa-tls
              mountPath: /certs
              readOnly: true
          ports:
            - containerPort: 8181
          livenessProbe:
            httpGet:
              path: /health
              port: 8181
              scheme: HTTPS
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /health
              port: 8181
              scheme: HTTPS
            initialDelaySeconds: 5
            periodSeconds: 5
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "128Mi"
              cpu: "200m"
      volumes:
        - name: opa-policies
          configMap:
            name: opa-policies
        - name: opa-tls
          secret:
            secretName: opa-server-tls
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: opa
  labels:
    app: opa
spec:
  selector:
    app: opa
  ports:
    - port: 8181
      targetPort: 8181
      protocol: TCP
```

Apply:
```bash
kubectl apply -f 04-opa-deployment.yaml
```

Wait for OPA to be ready:
```bash
kubectl wait --for=condition=ready pod -l app=opa -n opa --timeout=60s
```

---

## Step 6: Create Validating Webhook Configuration

### Why Webhook Configuration?
Tells Kubernetes API server to send admission requests to our OPA service.

**File: `05-webhook-configuration.yaml`**
```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: opa-validating-webhook
  labels:
    app: opa
webhooks:
  - name: validating-webhook.opa.example.com
    clientConfig:
      service:
        namespace: opa
        name: opa
        path: /v1/data/kubernetes/admission
        port: 8181
      caBundle: $(base64 -w 0 ca.crt)
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["*"]
        apiVersions: ["*"]
        resources: ["pods", "deployments"]
    admissionReviewVersions: ["v1"]
    sideEffects: None
    timeoutSeconds: 5
    failurePolicy: Fail
```

Apply (replace CA bundle):
```bash
# Get CA bundle
CA_BUNDLE=$(base64 -w 0 ca.crt)

# Create temporary file with actual CA bundle
cat > 05-webhook-configuration-applied.yaml <<EOF
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: opa-validating-webhook
  labels:
    app: opa
webhooks:
  - name: validating-webhook.opa.example.com
    clientConfig:
      service:
        namespace: opa
        name: opa
        path: /v1/data/kubernetes/admission
        port: 8181
      caBundle: $CA_BUNDLE
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["*"]
        apiVersions: ["*"]
        resources: ["pods", "deployments"]
    admissionReviewVersions: ["v1"]
    sideEffects: None
    timeoutSeconds: 5
    failurePolicy: Fail
EOF

kubectl apply -f 05-webhook-configuration-applied.yaml
```

---

## Step 7: Test the Setup

### Test 1: Create a Pod that should be DENIED

**File: `test-pod-denied.yaml`**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-denied
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:latest  # Violation: latest tag
    securityContext:
      privileged: true   # Violation: privileged container
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      # Missing limits - violation
  securityContext:
    runAsUser: 0  # Violation: root user
```

Test:
```bash
kubectl apply -f test-pod-denied.yaml
```
**Expected**: Should fail with policy violation messages

### Test 2: Create a Pod that should be ALLOWED

**File: `test-pod-allowed.yaml`**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod-allowed
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:1.25  # Specific version
    securityContext:
      privileged: false
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
  securityContext:
    runAsUser: 10001  # Non-root user
    runAsNonRoot: true
```

Test:
```bash
kubectl apply -f test-pod-allowed.yaml
```
**Expected**: Should succeed

### Test 3: Check OPA Logs
```bash
kubectl logs -l app=opa -n opa --tail=20
```

---

## Step 8: Manual Policy Testing

Test OPA policies directly:

```bash
# Port forward to OPA service
kubectl port-forward -n opa svc/opa 8181:8181 &

# Test policy evaluation
curl -k https://localhost:8181/v1/data/kubernetes/admission \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "request": {
        "uid": "test-uid",
        "kind": {"kind": "Pod", "version": "v1"},
        "resource": {"group": "", "version": "v1", "resource": "pods"},
        "namespace": "default",
        "operation": "CREATE",
        "userInfo": {
          "username": "test-user",
          "groups": ["system:authenticated"]
        },
        "object": {
          "metadata": {"name": "test-pod"},
          "spec": {
            "containers": [{
              "name": "test",
              "image": "nginx:latest",
              "securityContext": {"privileged": true},
              "resources": {
                "requests": {"memory": "64Mi", "cpu": "250m"}
              }
            }],
            "securityContext": {"runAsUser": 0}
          }
        }
      }
    }
  }' | jq .
```

---

## Step 9: Verification Commands

```bash
# Check all resources
kubectl get all -n opa

# Check webhook configuration
kubectl get validatingwebhookconfiguration

# Check OPA service
kubectl get svc -n opa

# Check pods
kubectl get pods -n opa

# Check OPA logs in real-time
kubectl logs -f -l app=opa -n opa
```

---

## Step 10: Cleanup

```bash
# Delete webhook first (to avoid blocking resource deletion)
kubectl delete validatingwebhookconfiguration opa-validating-webhook

# Delete OPA resources
kubectl delete -f 04-opa-deployment.yaml
kubectl delete -f 03-policies-configmap.yaml
kubectl delete -f 02-tls-secret.yaml
kubectl delete -f 01-namespace.yaml

# Delete test resources
kubectl delete pod test-pod-allowed --ignore-not-found=true

# Clean local files
rm -f ca.key ca.crt opa.key opa.crt opa.csr ca.srl opa.cnf
rm -f 05-webhook-configuration-applied.yaml
```

---

## Policy Explanation

### What each policy does:

1. **No Privileged Containers**: Prevents security risks
2. **No Latest Tags**: Ensures version stability
3. **No Root Users**: Security best practice
4. **Resource Limits Required**: Prevents resource exhaustion
5. **Non-root Required**: Security compliance

### Flow when creating a Pod:
1. `kubectl apply` sends request to API server
2. API server sends admission request to OPA webhook
3. OPA evaluates policies against the Pod spec
4. OPA returns ALLOW/DENY decision
5. API server proceeds or rejects based on response

This manual approach helps you understand each component and how they work together to provide fine-grained authorization beyond basic RBAC.
